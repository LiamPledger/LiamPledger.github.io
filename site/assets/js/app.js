const publications = [
  {
    id: "pledger2025phd",
    type: "thesis",
    year: 2025,
    title: "The effects of reducing design drift limits for structures",
    authors: "Pledger, L. J. T.",
    venue: "PhD dissertation, University of Canterbury",
    status: "Published",
    citations: null,
    apa: "Pledger, L. J. T. (2025). The effects of reducing design drift limits for structures [University of Canterbury]. https://doi.org/10.26021/16276",
    bibtex: "@phdthesis{pledger2025phd,\n  author={Pledger, Liam J. T.},\n  title={The effects of reducing design drift limits for structures},\n  school={University of Canterbury},\n  year={2025},\n  doi={10.26021/16276},\n  url={https://doi.org/10.26021/16276}\n}",
    links: [{ label: "DOI", url: "https://doi.org/10.26021/16276" }]
  },
  {
    id: "chaconvalero2025",
    type: "journal",
    year: 2025,
    title: "Effect of displacement cycles on the drift capacity of reinforced concrete structural walls",
    authors: "Chacon-Valero, E.; Pujol, S.; Hube, M.; Pledger, L.; Kerby, C.",
    venue: "Earthquake Spectra, 41(5), 3805-3825",
    status: "Published",
    citations: null,
    apa: "Chacon-Valero, E., Pujol, S., Hube, M., Pledger, L., & Kerby, C. (2025). Effect of displacement cycles on the drift capacity of reinforced concrete structural walls. Earthquake Spectra, 41(5), 3805-3825. https://doi.org/10.1177/87552930251377733",
    bibtex: "@article{chaconvalero2025,\n  author={Chacon-Valero, Edgar and Pujol, Santiago and Hube, Matias and Pledger, Liam and Kerby, Charles},\n  title={Effect of displacement cycles on the drift capacity of reinforced concrete structural walls},\n  journal={Earthquake Spectra},\n  year={2025},\n  volume={41},\n  number={5},\n  pages={3805--3825},\n  doi={10.1177/87552930251377733},\n  url={https://doi.org/10.1177/87552930251377733}\n}",
    links: [{ label: "DOI", url: "https://doi.org/10.1177/87552930251377733" }]
  },
  {
    id: "koroglu2025",
    type: "journal",
    year: 2025,
    title: "A fast seismic assessment technique for reinforced concrete buildings: Machine learning-based Hassan Index",
    authors: "Koroglu, F. B.; Gullu, M. F.; Ciftci, S.; Pledger, L.; Schill, C.; Pujol, S.",
    venue: "Structures, 82, 110425",
    status: "Published",
    citations: 0,
    apa: "Koroglu, F. B., Gullu, M. F., Ciftci, S., Pledger, L., Schill, C., & Pujol, S. (2025). A fast seismic assessment technique for reinforced concrete buildings: Machine learning-based Hassan Index. Structures, 82, 110425. https://doi.org/10.1016/j.istruc.2025.110425",
    bibtex: "@article{koroglu2025,\n  author={Koroglu, Fahri Baran and Gullu, Muhammet Fethi and Ciftci, Serdar and Pledger, Liam and Schill, Claudio and Pujol, Santiago},\n  title={A fast seismic assessment technique for reinforced concrete buildings: Machine learning-based Hassan Index},\n  journal={Structures},\n  year={2025},\n  volume={82},\n  pages={110425},\n  doi={10.1016/j.istruc.2025.110425},\n  url={https://doi.org/10.1016/j.istruc.2025.110425}\n}",
    links: [
      { label: "DOI", url: "https://doi.org/10.1016/j.istruc.2025.110425" },
      { label: "Preprint", url: "https://doi.org/10.31224/4675" }
    ]
  },
  {
    id: "pledger2026columns",
    type: "journal",
    year: 2026,
    title: "Estimating Drift Capacity of Reinforced Concrete Columns Using Machine Learning",
    authors: "Pledger, L.; Pujol, S.; Chandramohan, R.",
    venue: "ACI Structural Journal",
    status: "Published",
    citations: 0,
    apa: "Pledger, L., Pujol, S., & Chandramohan, R. (2026). Estimating Drift Capacity of Reinforced Concrete Columns Using Machine Learning. ACI Structural Journal. https://doi.org/10.14359/51749374",
    bibtex: "@article{pledger2026columns,\n  author={Pledger, Liam and Pujol, Santiago and Chandramohan, Reagan},\n  title={Estimating Drift Capacity of Reinforced Concrete Columns Using Machine Learning},\n  journal={ACI Structural Journal},\n  year={2026},\n  doi={10.14359/51749374},\n  url={https://doi.org/10.14359/51749374}\n}",
    links: [
      { label: "DOI", url: "https://doi.org/10.14359/51749374" },
      { label: "GitHuB repository", url: "https://github.com/LiamPledger/Drift-Capacity-of-RC-Columns" }
    ]
  },
  {
    id: "pledger2025wallframe",
    type: "journal",
    year: 2025,
    title: "Estimating the dynamic properties of wall-frame structures",
    authors: "Pledger, L.; Pujol, S.; Chandramohan, R.",
    venue: "Bulletin of the NZ Society for Earthquake Engineering",
    status: "Under review / in progress",
    citations: null,
    apa: "Pledger, L., Pujol, S., & Chandramohan, R. (2025). Estimating the dynamic properties of wall-frame structures [Manuscript under review].",
    bibtex: "@article{pledger2025wallframe,\n  author={Pledger, Liam and Pujol, Santiago and Chandramohan, Reagan},\n  title={Estimating the dynamic properties of wall-frame structures},\n  journal={Bulletin of the NZ Society for Earthquake Engineering},\n  year={2025},\n  note={Under review}\n}",
    links: [
      { label: "Bulletin early-access page", url: "https://bulletin.nzsee.org.nz/index.php/bnzsee" },
      { label: "Download manuscript (PDF)", url: "https://www.dropbox.com/scl/fi/mcohqzru0ba00yy12btt7/BNZSEE1714_Pledger-et-al_Estimating_the_dynamic_properties_of_wall-frame_structures.pdf?rlkey=yp14hhn45raw32nbe5579eqfw&dl=0" },
      { label: "GitHuB repository", url: "https://github.com/LiamPledger/Estimating-the-dynamic-properties-of-Wall-frame-structures" }
    ]
  },
  {
    id: "pledger2025im",
    type: "journal",
    year: 2025,
    title: "A comparison of ground motion intensity measures for estimating collapse",
    authors: "Pledger, L.; Sistla, S.; Pujol, S.; Chandramohan, R.",
    venue: "Earthquake Spectra",
    status: "Under review",
    citations: null,
    apa: "Pledger, L., Sistla, S., Pujol, S., & Chandramohan, R. (2025). A comparison of ground motion intensity measures for estimating collapse [Manuscript under review].",
    bibtex: "@article{pledger2025im,\n  author={Pledger, Liam and Sistla, S and Pujol, Santiago and Chandramohan, Reagan},\n  title={A comparison of ground motion intensity measures for estimating collapse},\n  journal={Earthquake Spectra},\n  year={2025},\n  note={Under review}\n}",
    links: [{ label: "GitHuB repository", url: "https://github.com/LiamPledger/PGV-and-other-ground-motion-intensity-measures-in-relation-to-building-drift-and-collapse" }]
  },
  {
    id: "pujol2024turkey",
    type: "journal",
    year: 2024,
    title: "Quantitative evaluation of the damage to RC buildings caused by the 2023 southeast Turkey earthquake sequence",
    authors: "Pujol, S.; Bedirhanoglu, I.; Donmez, C.; Dowgala, J. D.; et al.; Pledger, L.",
    venue: "Earthquake Spectra, 40(1), 505-530",
    status: "Published",
    citations: 53,
    apa: "Pujol, S., Bedirhanoglu, I., Donmez, C., Dowgala, J. D., Eryilmaz-Yildirim, M., Klaboe, K., Koroglu, F. B., Lequesne, R. D., Ozturk, B., Pledger, L., & Sonmez, E. (2024). Quantitative evaluation of the damage to RC buildings caused by the 2023 southeast Turkey earthquake sequence. Earthquake Spectra, 40(1), 505-530. https://doi.org/10.1177/87552930231211208",
    bibtex: "@article{pujol2024turkey,\n  author={Pujol, Santiago and Bedirhanoglu, Idris and Donmez, Cemalettin and Dowgala, Jeffrey D and Eryilmaz-Yildirim, Meltem and Klaboe, Kari and Koroglu, Fahri Baran and Lequesne, Remy D and Ozturk, Baki and Pledger, Liam and Sonmez, Egemen},\n  title={Quantitative evaluation of the damage to RC buildings caused by the 2023 southeast Turkey earthquake sequence},\n  journal={Earthquake Spectra},\n  year={2024},\n  volume={40},\n  number={1},\n  pages={505--530},\n  doi={10.1177/87552930231211208},\n  url={https://doi.org/10.1177/87552930231211208}\n}",
    links: [{ label: "DOI", url: "https://doi.org/10.1177/87552930231211208" }]
  },
  {
    id: "pledger2024atc",
    type: "conference",
    year: 2024,
    title: "Designing to lower drift limits: The impacts on construction costs and non-structural components",
    authors: "Pledger, L.; Pujol, S.; Calcagno, R.",
    venue: "ATC-15-17 Workshop, San Diego",
    status: "Conference proceeding",
    citations: 0,
    apa: "Pledger, L., Pujol, S., & Calcagno, R. (2024, December). Designing to lower drift limits: The impacts on construction costs and non-structural components. ATC-15-17 Workshop, San Diego, United States.",
    bibtex: "@inproceedings{pledger2024atc,\n  author={Pledger, Liam and Pujol, Santiago and Calcagno, R},\n  title={Designing to lower drift limits: The impacts on construction costs and non-structural components},\n  booktitle={18th U.S.-Japan-New Zealand Workshop on the Improvement of Structural Engineering and Resilience (ATC-15-17)},\n  year={2024},\n  address={San Diego, USA}\n}",
    links: [
      { label: "Download (ResearchGate)", url: "https://www.researchgate.net/profile/Liam-Pledger-2/publication/392903688_Designing_to_lower_drift_limits_the_impacts_on_construction_costs_and_non-structural_components/links/68577b06cdf1a35eb1749a7b/Designing-to-lower-drift-limits-the-impacts-on-construction-costs-and-non-structural-components.pdf" }
    ]
  },
  {
    id: "pledger2024wcee",
    type: "conference",
    year: 2024,
    title: "Reducing design drift limits",
    authors: "Pledger, L.; Pujol, S.; Chandramohan, R.",
    venue: "18th World Conference on Earthquake Engineering, Milan",
    status: "Conference proceeding",
    citations: 1,
    apa: "Pledger, L., Pujol, S., & Chandramohan, R. (2024, July). Reducing design drift limits. 18th World Conference on Earthquake Engineering, Milan, Italy.",
    bibtex: "@inproceedings{pledger2024wcee,\n  author={Pledger, Liam and Pujol, Santiago and Chandramohan, Reagan},\n  title={Reducing design drift limits},\n  booktitle={18th World Conference on Earthquake Engineering},\n  year={2024},\n  address={Milan, Italy}\n}",
    links: [{ label: "Download (ResearchGate)", url: "https://www.researchgate.net/publication/381968174_Quantifying_the_effect_of_reducing_seismic_drift_limits_on_the_performance_of_RC_frame_structures" }]
  },
  {
    id: "pledger2023nzsee",
    type: "conference",
    year: 2023,
    title: "Investigating the effect of stiffness on the seismic performance of RC structures",
    authors: "Pledger, L.; Pujol, S.; Chandramohan, R.",
    venue: "NZSEE Annual Conference",
    status: "Conference proceeding",
    citations: 9,
    apa: "Pledger, L., Pujol, S., & Chandramohan, R. (2023, April). Investigating the effect of stiffness on the seismic performance of RC structures. NZSEE Annual Conference, Auckland, New Zealand.",
    bibtex: "@inproceedings{pledger2023nzsee,\n  author={Pledger, Liam and Pujol, Santiago and Chandramohan, Reagan},\n  title={Investigating the effect of stiffness on the seismic performance of RC structures},\n  booktitle={NZSEE Annual Conference},\n  year={2023},\n  address={Auckland, New Zealand},\n  url={http://13.237.132.70/handle/nzsee/2570}\n}",
    links: [{ label: "Proceedings", url: "http://13.237.132.70/handle/nzsee/2570" }]
  }
];

function setupMobileMenu() {
  const sidebar = document.getElementById("sidebar");
  const button = document.getElementById("mobile-menu-btn");
  if (!sidebar || !button) return;

  button.addEventListener("click", () => {
    sidebar.classList.toggle("open");
  });

  sidebar.querySelectorAll("a").forEach((link) => {
    link.addEventListener("click", () => {
      sidebar.classList.remove("open");
    });
  });
}

function setActiveNav() {
  const page = document.body?.dataset?.page;
  if (!page) return;

  document.querySelectorAll("[data-nav]").forEach((link) => {
    if (link.dataset.nav === page) {
      link.classList.add("active");
    }
  });
}

function updateStats() {
  const pubCountEl = document.getElementById("pub-count");
  const citationEl = document.getElementById("citation-total");
  const totalCitations = publications.reduce((acc, p) => (Number.isFinite(p.citations) ? acc + p.citations : acc), 0);

  if (pubCountEl) pubCountEl.textContent = String(publications.length);
  if (citationEl) citationEl.textContent = String(totalCitations);
}

function downloadText(filename, text) {
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

function renderPublications(filter = "all") {
  const container = document.getElementById("pub-list");
  if (!container) return;

  const visible = publications
    .filter((p) => filter === "all" || p.type === filter)
    .sort((a, b) => b.year - a.year);

  container.innerHTML = visible
    .map((p) => {
      const links = p.links
        .map((l) => `<a href="${l.url}" target="_blank" rel="noopener">${l.label}</a>`)
        .join("");

      return `
        <article class="pub-item">
          <h3>${p.title}</h3>
          <p class="pub-meta">${p.authors} | ${p.venue} | ${p.year} | ${p.status}</p>
          <p class="pub-apa"><strong>APA:</strong> ${p.apa}</p>
          <div class="pub-links">
            ${links}
            <button type="button" data-action="download-bib" data-id="${p.id}">Download BibTeX</button>
          </div>
        </article>
      `;
    })
    .join("");
}

function bindPublicationActions() {
  const container = document.getElementById("pub-list");
  if (!container) return;

  container.addEventListener("click", (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.dataset.action !== "download-bib") return;

    const pub = publications.find((p) => p.id === target.dataset.id);
    if (!pub) return;
    downloadText(`${pub.id}.bib`, pub.bibtex + "\n");
  });
}

function bindFilters() {
  const chips = document.querySelectorAll(".chip");
  if (!chips.length) return;

  chips.forEach((chip) => {
    chip.addEventListener("click", () => {
      chips.forEach((c) => c.classList.remove("active"));
      chip.classList.add("active");
      renderPublications(chip.dataset.filter || "all");
    });
  });
}

function renderLastUpdated() {
  const nodes = document.querySelectorAll("[data-last-updated]");
  if (!nodes.length) return;

  const source = document.lastModified ? new Date(document.lastModified) : new Date();
  const text = `Last updated: ${source.getFullYear()}`;
  nodes.forEach((node) => {
    node.textContent = text;
  });
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function debounce(fn, delayMs = 120) {
  let timer = null;
  return (...args) => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delayMs);
  };
}

function getColumnModelUrl() {
  if (window.COLUMN_LGBM_MODEL_URL && typeof window.COLUMN_LGBM_MODEL_URL === "string") {
    return window.COLUMN_LGBM_MODEL_URL.trim();
  }
  return "assets/models/column_model.txt";
}

function getWallModelUrl() {
  if (window.WALL_LGBM_MODEL_URL && typeof window.WALL_LGBM_MODEL_URL === "string") {
    return window.WALL_LGBM_MODEL_URL.trim();
  }
  return "assets/models/wall_model.txt";
}

function parseNumberArray(raw) {
  const text = String(raw || "").trim();
  if (!text) return [];
  return text.split(/\s+/).map((token) => {
    const normalized = token.toLowerCase();
    if (normalized === "inf" || normalized === "+inf" || normalized === "infinity" || normalized === "+infinity") {
      return Infinity;
    }
    if (normalized === "-inf" || normalized === "-infinity") {
      return -Infinity;
    }
    if (normalized === "nan" || normalized === "+nan" || normalized === "-nan") {
      return Number.NaN;
    }
    return Number(token);
  });
}

function parseIntegerArray(raw) {
  const text = String(raw || "").trim();
  if (!text) return [];
  return text.split(/\s+/).map((token) => Number.parseInt(token, 10));
}

function parseLightGbmModelText(content) {
  const lines = String(content || "")
    .split(/\r?\n/)
    .map((line) => line.trim());

  if (!lines.length) {
    throw new Error("Model file is empty.");
  }

  const model = {
    objective: "",
    maxFeatureIdx: null,
    trees: []
  };

  let idx = 0;
  while (idx < lines.length && !lines[idx].startsWith("Tree=")) {
    const line = lines[idx];
    if (line.startsWith("objective=")) {
      model.objective = line.slice("objective=".length).trim();
    } else if (line.startsWith("max_feature_idx=")) {
      model.maxFeatureIdx = Number.parseInt(line.slice("max_feature_idx=".length), 10);
    }
    idx += 1;
  }

  while (idx < lines.length) {
    const line = lines[idx];
    if (!line) {
      idx += 1;
      continue;
    }
    if (!line.startsWith("Tree=")) {
      idx += 1;
      continue;
    }

    const tree = {
      splitFeature: [],
      threshold: [],
      decisionType: [],
      leftChild: [],
      rightChild: [],
      leafValue: [],
      shrinkage: 1
    };

    idx += 1;
    while (idx < lines.length) {
      const row = lines[idx];
      if (!row) {
        idx += 1;
        continue;
      }
      if (row.startsWith("Tree=") || row === "end of trees" || row === "feature_importances:") {
        break;
      }

      const splitAt = row.indexOf("=");
      if (splitAt >= 0) {
        const key = row.slice(0, splitAt).trim();
        const value = row.slice(splitAt + 1).trim();
        if (key === "split_feature") tree.splitFeature = parseIntegerArray(value);
        else if (key === "threshold") tree.threshold = parseNumberArray(value);
        else if (key === "decision_type") tree.decisionType = parseIntegerArray(value);
        else if (key === "left_child") tree.leftChild = parseIntegerArray(value);
        else if (key === "right_child") tree.rightChild = parseIntegerArray(value);
        else if (key === "leaf_value") tree.leafValue = parseNumberArray(value);
        else if (key === "shrinkage") {
          const shrinkage = Number(value);
          tree.shrinkage = Number.isFinite(shrinkage) ? shrinkage : 1;
        }
      }

      idx += 1;
    }

    if (!tree.leafValue.length) {
      throw new Error("Model parsing failed: missing leaf values.");
    }
    model.trees.push(tree);
  }

  if (!model.trees.length) {
    throw new Error("Model parsing failed: no trees found.");
  }
  return model;
}

function predictTreeValue(tree, features) {
  let node = 0;
  let guard = 0;
  const maxSteps = Math.max(8, tree.splitFeature.length + 8);

  while (node >= 0 && guard < maxSteps) {
    guard += 1;

    const featureIndex = tree.splitFeature[node];
    if (!Number.isInteger(featureIndex) || featureIndex < 0 || featureIndex >= features.length) {
      throw new Error("Model traversal failed: invalid feature index.");
    }
    const decisionType = Number.isInteger(tree.decisionType[node]) ? tree.decisionType[node] : 0;
    if ((decisionType & 1) !== 0) {
      throw new Error("Categorical LightGBM splits are not supported by the browser predictor.");
    }

    const featureValue = features[featureIndex];
    const threshold = tree.threshold[node];
    const defaultLeft = (decisionType & 2) !== 0;
    const missingType = (decisionType & 12) >> 2; // 0: none, 1: zero, 2: NaN

    let goLeft;
    if (missingType === 1 && featureValue === 0) {
      goLeft = defaultLeft;
    } else if (missingType === 2 && Number.isNaN(featureValue)) {
      goLeft = defaultLeft;
    } else {
      goLeft = featureValue <= threshold;
    }

    node = goLeft ? tree.leftChild[node] : tree.rightChild[node];
  }

  if (node >= 0) {
    throw new Error("Model traversal failed: tree traversal did not terminate.");
  }

  const leafIndex = -node - 1;
  if (!Number.isInteger(leafIndex) || leafIndex < 0 || leafIndex >= tree.leafValue.length) {
    throw new Error("Model traversal failed: invalid leaf index.");
  }

  return tree.leafValue[leafIndex] * tree.shrinkage;
}

function predictLightGbm(model, features) {
  if (!Array.isArray(features) || !features.every((value) => Number.isFinite(value))) {
    throw new Error("Invalid input features for prediction.");
  }

  let prediction = 0;
  model.trees.forEach((tree) => {
    prediction += predictTreeValue(tree, features);
  });

  if (!Number.isFinite(prediction)) {
    throw new Error("Prediction failed.");
  }
  return prediction;
}

const lightGbmModelCache = new Map();
async function loadLightGbmModel(url) {
  const normalized = String(url || "").trim();
  if (!normalized) {
    throw new Error("Missing model URL.");
  }

  if (lightGbmModelCache.has(normalized)) {
    return lightGbmModelCache.get(normalized);
  }

  const promise = (async () => {
    const response = await fetch(normalized, { cache: "no-cache" });
    if (!response.ok) {
      throw new Error(`Model file unavailable at ${normalized} (HTTP ${response.status}).`);
    }
    const text = await response.text();
    return parseLightGbmModelText(text);
  })();

  lightGbmModelCache.set(normalized, promise);
  try {
    return await promise;
  } catch (error) {
    lightGbmModelCache.delete(normalized);
    throw error;
  }
}

function createModelForm(containerId, params, onValueChange) {
  const container = document.getElementById(containerId);
  if (!container) return;

  const state = {};

  params.forEach((p) => {
    state[p.id] = p.value;

    const row = document.createElement("div");
    row.className = "model-row";

    const top = document.createElement("div");
    top.className = "model-row-top";
    const label = document.createElement("label");
    label.innerHTML = p.label;
    const rangeText = document.createElement("span");
    rangeText.className = "param-range";
    rangeText.textContent = `${p.min} to ${p.max}`;
    top.appendChild(label);
    top.appendChild(rangeText);

    const controls = document.createElement("div");
    controls.className = "model-inputs";

    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = String(p.min);
    slider.max = String(p.max);
    slider.step = String(p.step);
    slider.value = String(p.value);

    const number = document.createElement("input");
    number.type = "number";
    number.min = String(p.min);
    number.max = String(p.max);
    number.step = String(p.step);
    number.value = String(p.value);

    const sync = (raw) => {
      const numeric = Number(raw);
      const safe = Number.isFinite(numeric) ? clamp(numeric, p.min, p.max) : p.value;
      const rounded = Number(safe.toFixed(6));
      slider.value = String(rounded);
      number.value = String(rounded);
      state[p.id] = rounded;
      onValueChange({ ...state });
    };

    slider.addEventListener("input", (e) => sync(e.target.value));
    number.addEventListener("input", (e) => sync(e.target.value));

    controls.appendChild(slider);
    controls.appendChild(number);
    row.appendChild(top);
    row.appendChild(controls);
    container.appendChild(row);
  });

  onValueChange({ ...state });
}

function setupColumnModel() {
  const formContainer = document.getElementById("column-model-form");
  const resultEl = document.getElementById("column-model-result");
  if (!formContainer || !resultEl) return;

  const modelPromise = loadLightGbmModel(getColumnModelUrl());
  let requestVersion = 0;
  const debouncedPredict = debounce(async (state, version) => {
    try {
      const model = await modelPromise;
      const features = [
        state.a,
        state.a / state.d,
        state.fyt,
        state.s / state.d,
        state.fc,
        state.v,
        state.s / state.lbd,
        state.a / state.s,
        state.rhol * state.fyl,
        state.rhot * state.fyt
      ];
      const prediction = predictLightGbm(model, features);
      if (version !== requestVersion) return;
      resultEl.textContent = `Estimated drift capacity: ${prediction.toFixed(2)} %.`;
    } catch (error) {
      if (version !== requestVersion) return;
      const detail = error instanceof Error ? error.message : "Unable to load browser model.";
      resultEl.textContent = `Model unavailable: ${detail}`;
    }
  }, 160);

  createModelForm(
      "column-model-form",
      [
      { id: "a", label: "<i>a</i> (mm) - Shear span", value: 1000, min: 200, max: 2000, step: 50 },
      { id: "d", label: "<i>d</i> (mm) - Column section depth", value: 500, min: 100, max: 1000, step: 10 },
      { id: "s", label: "<i>s</i> (mm) - Transverse reinforcement spacing", value: 100, min: 50, max: 500, step: 10 },
      { id: "fc", label: "<i>f</i>'<sub>c</sub> (MPa) - Concrete compressive strength", value: 30, min: 20, max: 90, step: 1 },
      { id: "fyl", label: "<i>f</i><sub>yl</sub> (MPa) - Longitudinal steel yield strength", value: 500, min: 250, max: 550, step: 10 },
      { id: "fyt", label: "<i>f</i><sub>yt</sub> (MPa) - Transverse steel yield strength", value: 500, min: 250, max: 1000, step: 10 },
      { id: "rhol", label: "&rho;<sub>l</sub> (%) - Longitudinal reinforcement ratio", value: 2.0, min: 0.0, max: 5.0, step: 0.1 },
      { id: "rhot", label: "&rho;<sub>t</sub> (%) - Transverse reinforcement ratio", value: 0.4, min: 0.0, max: 2.0, step: 0.05 },
      { id: "v", label: "<i>P</i> / (<i>A</i><sub>g</sub><i>f</i>'<sub>c</sub>) - Axial load ratio", value: 0.2, min: 0.0, max: 0.75, step: 0.05 },
      { id: "lbd", label: "<i>l</i><sub>bd</sub> (mm) - Longitudinal bar diameter", value: 25, min: 5, max: 40, step: 1 }
      ],
    (state) => {
      requestVersion += 1;
      const version = requestVersion;
      resultEl.textContent = "Calculating...";
      debouncedPredict(state, version);
    }
  );
}

function setupWallModel() {
  const formContainer = document.getElementById("wall-model-form");
  const resultEl = document.getElementById("wall-model-result");
  if (!formContainer || !resultEl) return;

  const modelPromise = loadLightGbmModel(getWallModelUrl());
  let requestVersion = 0;
  const debouncedPredict = debounce(async (state, version) => {
    try {
      const model = await modelPromise;
      const features = [
        state.h / state.Lw,
        state.Lw / state.t,
        state.fc,
        state.t / state.h,
        state.s / state.h,
        state.rholb * state.Fy,
        state.rhotb * state.Fy,
        state.ALR
      ];
      const prediction = predictLightGbm(model, features);
      if (version !== requestVersion) return;
      resultEl.textContent = `Estimated drift capacity: ${prediction.toFixed(2)} %.`;
    } catch (error) {
      if (version !== requestVersion) return;
      const detail = error instanceof Error ? error.message : "Unable to load browser model.";
      resultEl.textContent = `Model unavailable: ${detail}`;
    }
  }, 160);

  createModelForm(
    "wall-model-form",
    [
      { id: "fc", label: "<i>f</i>'<sub>c</sub> (MPa) - Concrete compressive strength", value: 30, min: 20, max: 100, step: 1 },
      { id: "Lw", label: "<i>l</i><sub>w</sub> (mm) - Wall length", value: 3000, min: 1000, max: 12000, step: 100 },
      { id: "t", label: "<i>t</i> (mm) - Wall thickness", value: 300, min: 50, max: 1000, step: 10 },
      { id: "h", label: "<i>h</i> (mm) - Wall height", value: 3000, min: 1000, max: 50000, step: 100 },
      { id: "s", label: "<i>s</i> (mm) - Boundary stirrup spacing", value: 100, min: 10, max: 300, step: 10 },
      { id: "rholb", label: "&rho;<sub>lb</sub> (%) - Longitudinal boundary reinforcement ratio", value: 2.0, min: 0.0, max: 5.0, step: 0.1 },
      { id: "rhotb", label: "&rho;<sub>tb</sub> (%) - Transverse boundary reinforcement ratio", value: 0.4, min: 0.0, max: 5.0, step: 0.1 },
      { id: "Fy", label: "<i>f</i><sub>y</sub> (MPa) - Reinforcement yield strength", value: 500, min: 300, max: 1000, step: 10 },
      { id: "ALR", label: "<i>P</i> / (<i>A</i><sub>g</sub><i>f</i>'<sub>c</sub>) - Axial load ratio", value: 0.2, min: 0.0, max: 0.4, step: 0.01 }
    ],
    (state) => {
      requestVersion += 1;
      const version = requestVersion;
      resultEl.textContent = "Calculating...";
      debouncedPredict(state, version);
    }
  );
}

setActiveNav();
setupMobileMenu();
updateStats();
renderPublications();
bindPublicationActions();
bindFilters();
setupColumnModel();
setupWallModel();
renderLastUpdated();
